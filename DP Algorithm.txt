Chaff

{
    "data": [
        {"name":  "Timesheet" , "emotion":  -1 , "urgency":  3 , "duration": 1, "energy": -1 },
        {"name":  "CLI Guide" , "emotion":  3 , "urgency":  2 , "duration": 2, "energy": -2 },
        {"name":  "Spanish Email" , "emotion":  -5 , "urgency":  1 , "duration": 2, "energy": 4 },
        {"name":  "Diversity Lab Email Survey" , "emotion":  -2 , "urgency":  3 , "duration": 1, "energy": 1 },
        {"name":  "Isabella Presentation" , "emotion":  -3 , "urgency":  2 , "duration": 2, "energy": 3 },
        {"name":  "Clean Room" , "emotion":  -2 , "urgency": 1 , "duration": 3, "energy": 0 },
        {"name":  "Harry Potter Drama" , "emotion":  2 , "urgency":  1 , "duration": 3, "energy": -2 },
        {"name":  "Work Out" , "emotion":  -3 , "urgency": 2 , "duration": 2, "energy": 5 },
        {"name":  "Set meeting with Lauren" , "emotion":  0 , "urgency":  3 , "duration": 1, "energy": 0 },
        {"name":  "Order Chargers" , "emotion":  -2 , "urgency":  2 , "duration": 1, "energy": 1 },
        {"name":  "Put teacups in dishwasher" , "emotion":  0 , "urgency":  2 , "duration": 1, "energy": 0 },
        {"name":  "Work on ToDo app" , "emotion":  5 , "urgency":  1 , "duration": 3, "energy": 4 },
        {"name":  "Order Headphones" , "emotion":  -1 , "urgency":  1 , "duration": 2, "energy": -1 },
        {"name":  "SlateStarCodex Article" , "emotion":  2 , "urgency":  1 , "duration": 1, "energy": -1 },
        {"name":  "Psych Article" , "emotion":  2 , "urgency":  1 , "duration": 1, "energy": -2 }
    ]
}



//How do you stop from reusing tasks?
//I think the way to do it is that each iteration is the next task, not the next dur.
//so you start with an empty grid
//you see where you can get with just task 1 and record the durs
//then you pass the updated graph to task 2
//see where task 2 can get on its own, AND where it can get with task 1 as well
//...
//on nth iteration, you are looking at nth task.

//since you know the tasks are used in order, it would appear that retracing would be easy, but idk.

//start with the 1st task and go to 0,0 and then theres only 1 other square you can reach.
//say that square is i,j. you now have [i][j][1] = (1)
//next, task 2 can reach 2 squares. One of them is [x][y][1] and one is [x][y][2]
//next, task 3 can reach 4 squares, since it can start at 0,0 or the square reached by task 1 or either of the two squares reached by task 2
//next, task 4 can reach 1 + 1 + 2 + 4 = 8 squares
//ok, so the number is doubling every time, which means this is exponential.
//MAYBE you only have to pass the updated squares each time, but still exponential.
//however, you dont have to pass squares once they reach max_dur, which for this example we will say is 4.
//next, task 5 can reach 1 + 1 + 2 + 4 + 8 = 16 squares - 1 = 15 squares, since the square with path 1,2,3,4 has reached max_dur
//next, task 6 can reach 1 + 1 + 2 + 4 + 8 + 15 - ? = ??
//Why dont I just write this algorithm and record how many squares each layer reaches with the number of tasks I have now (which is 15, so if it doubles every time it would be 2^15=32,768)

//---------
// if i wanted to make this a graph problem:
// visualize [emotion][energy] coordinate grid as the map
// starting from every position and trying to get to [0][0] in a fixed amount of moves (max_dur)
// therefore, every task is a vector with a certain weight

// flip it around: starting from 0,0 and want to find the best path to every other square
// at every square i,j store (max_dur - dur) aka remaining time left
// if i am at i,j with 1 hour left, then every square I can reach in an hour is a potential 0,0 schedule
// since every task is a vector, would just get every dur=1 task and i+task_i, j+task_j ...
// PROBLEM: need to go from 0,0 BACK TO 0,0
// what this really means is at i,j I need two paths from 0,0 to i,j with NO shared tasks and whose durs sum to max_dur

// well, assuming I had all possible paths to every point, I would just sort by dur and do a left/right pointer to find all pairs of durs that sum to max_dur
// but id have to do that on every point, and thats AFTER i already did DP

// ALTERNATIVELY, if I get to i,j with dur = max - 1, id simply need to know all dur=1 paths to the same square
// therefore, if i get there with dur = max - 2, id just need all dur=2 paths, etc etc
//

//since every task is a vector, could just retrace the path if u store (dur, task) at each square.

//Problems:
	//1. Idk if I can even copy a struct that has a list of other structs in it
	//2. Even if I can, am I making new lists for every recursion? seems like a lot of storage.
	//Best solution then would be to store some info in DP. Maybe I store the indices of remaining tasks,
	//since I dont actually need to access them except for duration. And even if I did want to access duration,
	//I would just store duration as the DP variable so I'd only ever need to access it once.
	//
	//Basically, DP will be a list indexed by duration, and at every index there is a list of lists,
	//which is all possible combinations of tasks that add up to that duration.
	//only even need to go to max_dur/2, since after that I can just use the groupings as items instead of the itemds themselves.
	//
	//OR
	//would the DP be like the "dp[gas station stops][distance]=x" DP, whihc in this case would be
	//"dp[emotion][energy]=duration". but would you minimize duration or maximize it?
	//maybe youd say "dp[emotion][duration] = most balanced energy"
	//
	//lets assume there are always 4 tasks (eliminate duration for now).
	//make 4 nxn matrices, where n=len(tasks).
	//M1[em][en] = [all [task list of size 1] that equal that em and en]
	//M2 is same but for all task lists of size 2.
	//
	//
	//
	//Better way to do this is by thinking it through with induction.
	//cases:
	// - i have 3 tasks already, how am i choosing the 4th?
	// - only have 1 task per day
	// - only have 2 tasks per day
